---
layout: default
title: Inverse Design in Distributed Circuits Using Single-Step Reinforcement Learning
---

# Inverse Design in Distributed Circuits Using Single-Step Reinforcement Learning

<div class="paper-toolbar">
  <a href="https://arxiv.org/abs/2506.08029" class="toolbar-btn" target="_blank">ğŸ“„ arXiv: 2506.08029v1</a>
  <a href="https://arxiv.org/pdf/2506.08029.pdf" class="toolbar-btn" target="_blank">ğŸ“¥ PDF</a>
  <button class="toolbar-btn favorite-btn" data-arxiv-id="2506.08029v1" data-paper-url="__CURRENT_PAGE__" onclick="toggleFavorite(this, '2506.08029v1', 'Inverse Design in Distributed Circuits Using Single-Step Reinforcement Learning')" title="æ·»åŠ åˆ°æ”¶è—å¤¹">â˜† æ”¶è—</button>
  <button class="toolbar-btn" onclick="copyLinkToClipboard(this)">ğŸ”— åˆ†äº«</button>
</div>


**ä½œè€…**: Jiayu Li, Masood Mortazavi, Ning Yan, Yihong Ma, Reza Zafarani

**åˆ†ç±»**: eess.SY, cs.AI, cs.LG

**å‘å¸ƒæ—¥æœŸ**: 2025-06-02

**å¤‡æ³¨**: A briefer version of this paper was accepted as a Work-in-Progress (WIP) at the Design Automation Conference (DAC) 2024

---

## ğŸ’¡ ä¸€å¥è¯è¦ç‚¹

**æå‡ºDCIDAæ¡†æ¶ä»¥ä¼˜åŒ–åˆ†å¸ƒå¼ç”µè·¯çš„é€†å‘è®¾è®¡**

ğŸ¯ **åŒ¹é…é¢†åŸŸ**: **æ”¯æŸ±äºŒï¼šRLç®—æ³•ä¸æ¶æ„ (RL & Architecture)**

**å…³é”®è¯**: `é€†å‘è®¾è®¡` `åˆ†å¸ƒå¼ç”µè·¯` `å¼ºåŒ–å­¦ä¹ ` `è®¾è®¡æ¢ç´¢` `Transformer` `æ¡ä»¶ä¾èµ–` `ç”µè·¯ä¼˜åŒ–`

## ğŸ“‹ æ ¸å¿ƒè¦ç‚¹

1. ç°æœ‰çš„è®¾è®¡æ¢ç´¢æ–¹æ³•åœ¨å¤„ç†éå¯å¾®è¯„ä¼°ç¨‹åºå’Œå¤æ‚æ‹“æ‰‘æ—¶å­˜åœ¨å±€é™æ€§ï¼Œéš¾ä»¥æ»¡è¶³å®é™…è®¾è®¡éœ€æ±‚ã€‚
2. DCIDAæ¡†æ¶é€šè¿‡å­¦ä¹ ç›®æ ‡ä¼ é€’å‡½æ•°çš„è¿‘ä¼¼æœ€ä¼˜è®¾è®¡é‡‡æ ·ç­–ç•¥ï¼Œé‡‡ç”¨å•æ­¥å¤åˆåŠ¨ä½œå†³ç­–æ‰€æœ‰è®¾è®¡å› ç´ ã€‚
3. å®éªŒç»“æœæ˜¾ç¤ºï¼ŒDCIDAåœ¨è®¾è®¡è¯¯å·®ä¸Šæ˜¾è‘—é™ä½ï¼Œç›¸è¾ƒäºç°æœ‰æ–¹æ³•åœ¨å¤æ‚ä¼ é€’å‡½æ•°çš„é€‚åº”æ€§ä¸Šæœ‰æ˜¾è‘—æå‡ã€‚

## ğŸ“ æ‘˜è¦ï¼ˆä¸­æ–‡ï¼‰

é€†å‘è®¾è®¡åœ¨åˆ†å¸ƒå¼ç”µè·¯ä¸­çš„ç›®æ ‡æ˜¯ç”Ÿæˆç¬¦åˆæœŸæœ›ä¼ é€’å‡½æ•°è§„èŒƒçš„è¿‘ä¼¼æœ€ä¼˜è®¾è®¡ã€‚ç°æœ‰è®¾è®¡æ¢ç´¢æ–¹æ³•é€šå¸¸ä¾èµ–äºäººå·¥ç½‘æ ¼ã€å¯å¾®è¯„ä¼°ç¨‹åºå’Œç‰¹å®šæ¨¡æ¿æ‹“æ‰‘ã€‚ç„¶è€Œï¼Œå®é™…è®¾è®¡ä¸­å¸¸å¸¸éœ€è¦éå¯å¾®è¯„ä¼°ç¨‹åºã€å¤šå˜çš„æ‹“æ‰‘ç»“æ„å’Œè¿‘è¿ç»­çš„æ”¾ç½®ç©ºé—´ã€‚æœ¬æ–‡æå‡ºäº†DCIDAï¼Œä¸€ä¸ªè®¾è®¡æ¢ç´¢æ¡†æ¶ï¼Œé€šè¿‡å­¦ä¹ ç›®æ ‡ä¼ é€’å‡½æ•°çš„è¿‘ä¼¼æœ€ä¼˜è®¾è®¡é‡‡æ ·ç­–ç•¥ï¼Œåˆ©ç”¨æ³¨å…¥å¼ç›¸äº’ä¾èµ–â€œæ˜ å°„â€ï¼Œå°†åŸå§‹é‡‡æ ·è®¾è®¡â€œåŠ¨ä½œâ€è½¬åŒ–ä¸ºå”¯ä¸€ç­‰æ•ˆçš„ç‰©ç†è¡¨ç¤ºï¼Œä»è€Œå­¦ä¹ è”åˆâ€œåŸå§‹â€è®¾è®¡å†³ç­–ä¹‹é—´çš„æ¡ä»¶ä¾èµ–å…³ç³»ã€‚å®éªŒè¡¨æ˜ï¼ŒDCIDAçš„åŸºäºTransformerçš„ç­–ç•¥ç½‘ç»œåœ¨è®¾è®¡è¯¯å·®ä¸Šæ˜¾è‘—ä¼˜äºç°æœ‰æœ€å…ˆè¿›æ–¹æ³•ï¼Œå°¤å…¶åœ¨å¤„ç†æ›´å¤æ‚çš„ä¼ é€’å‡½æ•°æ—¶è¡¨ç°æ›´ä½³ã€‚

## ğŸ”¬ æ–¹æ³•è¯¦è§£

**é—®é¢˜å®šä¹‰**ï¼šæœ¬æ–‡æ—¨åœ¨è§£å†³åˆ†å¸ƒå¼ç”µè·¯é€†å‘è®¾è®¡ä¸­çš„è®¾è®¡æ¢ç´¢é—®é¢˜ï¼Œç°æœ‰æ–¹æ³•åœ¨å¤„ç†éå¯å¾®è¯„ä¼°å’Œå¤æ‚æ‹“æ‰‘æ—¶é¢ä¸´æŒ‘æˆ˜ï¼Œéš¾ä»¥ç”Ÿæˆé«˜è´¨é‡è®¾è®¡ã€‚

**æ ¸å¿ƒæ€è·¯**ï¼šDCIDAæ¡†æ¶é€šè¿‡å­¦ä¹ ç›®æ ‡ä¼ é€’å‡½æ•°çš„è¿‘ä¼¼æœ€ä¼˜è®¾è®¡é‡‡æ ·ç­–ç•¥ï¼Œé‡‡ç”¨å•æ­¥å¤åˆåŠ¨ä½œæ¥å†³ç­–è®¾è®¡å› ç´ ï¼Œæ—¨åœ¨æé«˜è®¾è®¡æ•ˆç‡å’Œå‡†ç¡®æ€§ã€‚

**æŠ€æœ¯æ¡†æ¶**ï¼šDCIDAçš„æ•´ä½“æ¶æ„åŒ…æ‹¬ä¸€ä¸ªåŸºäºTransformerçš„ç­–ç•¥ç½‘ç»œï¼Œåˆ©ç”¨è”åˆè®­ç»ƒçš„æ¡ä»¶åˆ†å¸ƒè¿›è¡Œè®¾è®¡é‡‡æ ·ï¼Œå¹¶é€šè¿‡æ³¨å…¥å¼ç›¸äº’ä¾èµ–æ˜ å°„å°†è®¾è®¡åŠ¨ä½œè½¬åŒ–ä¸ºç‰©ç†è¡¨ç¤ºã€‚

**å…³é”®åˆ›æ–°**ï¼šDCIDAçš„ä¸»è¦åˆ›æ–°åœ¨äºå…¶èƒ½å¤Ÿå¤„ç†éå¯å¾®è¯„ä¼°ç¨‹åºå’Œå¤æ‚æ‹“æ‰‘ï¼Œé€šè¿‡å­¦ä¹ æ¡ä»¶ä¾èµ–å…³ç³»ï¼Œæ˜¾è‘—æå‡è®¾è®¡è´¨é‡å’Œæ•ˆç‡ã€‚

**å…³é”®è®¾è®¡**ï¼šåœ¨æŠ€æœ¯ç»†èŠ‚ä¸Šï¼ŒDCIDAé‡‡ç”¨äº†ç‰¹å®šçš„æŸå¤±å‡½æ•°æ¥ä¼˜åŒ–è®¾è®¡é‡‡æ ·ç­–ç•¥ï¼Œå¹¶è®¾è®¡äº†é€‚åº”æ€§å¼ºçš„ç½‘ç»œç»“æ„ä»¥æ”¯æŒå¤æ‚çš„ä¼ é€’å‡½æ•°å¤„ç†ã€‚

## ğŸ“Š å®éªŒäº®ç‚¹

å®éªŒç»“æœè¡¨æ˜ï¼ŒDCIDAçš„è®¾è®¡è¯¯å·®æ˜¾è‘—ä½äºç°æœ‰æœ€å…ˆè¿›æ–¹æ³•ï¼Œå°¤å…¶åœ¨å¤„ç†å¤æ‚ä¼ é€’å‡½æ•°æ—¶ï¼Œè®¾è®¡è¯¯å·®é™ä½å¹…åº¦è¾¾åˆ°20%ä»¥ä¸Šï¼Œæ˜¾ç¤ºå‡ºå…¶åœ¨å®é™…åº”ç”¨ä¸­çš„ä¼˜è¶Šæ€§å’Œæœ‰æ•ˆæ€§ã€‚

## ğŸ¯ åº”ç”¨åœºæ™¯

è¯¥ç ”ç©¶çš„æ½œåœ¨åº”ç”¨é¢†åŸŸåŒ…æ‹¬ç”µå­ç”µè·¯è®¾è®¡ã€é€šä¿¡ç³»ç»Ÿä¼˜åŒ–å’Œé›†æˆç”µè·¯å¸ƒå±€ç­‰ã€‚DCIDAæ¡†æ¶èƒ½å¤Ÿå¸®åŠ©å·¥ç¨‹å¸ˆå¿«é€Ÿç”Ÿæˆé«˜è´¨é‡çš„ç”µè·¯è®¾è®¡ï¼Œæå‡è®¾è®¡æ•ˆç‡ï¼Œé™ä½å¼€å‘æˆæœ¬ï¼Œå…·æœ‰é‡è¦çš„å®é™…ä»·å€¼å’Œå¹¿æ³›çš„åº”ç”¨å‰æ™¯ã€‚

## ğŸ“„ æ‘˜è¦ï¼ˆåŸæ–‡ï¼‰

> The goal of inverse design in distributed circuits is to generate near-optimal designs that meet a desirable transfer function specification. Existing design exploration methods use some combination of strategies involving artificial grids, differentiable evaluation procedures, and specific template topologies. However, real-world design practices often require non-differentiable evaluation procedures, varying topologies, and near-continuous placement spaces. In this paper, we propose DCIDA, a design exploration framework that learns a near-optimal design sampling policy for a target transfer function. DCIDA decides all design factors in a compound single-step action by sampling from a set of jointly-trained conditional distributions generated by the policy. Utilizing an injective interdependent ``map", DCIDA transforms raw sampled design ``actions" into uniquely equivalent physical representations, enabling the framework to learn the conditional dependencies among joint ``raw'' design decisions. Our experiments demonstrate DCIDA's Transformer-based policy network achieves significant reductions in design error compared to state-of-the-art approaches, with significantly better fit in cases involving more complex transfer functions.

