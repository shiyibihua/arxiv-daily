---
layout: default
title: Localized Calibrated Uncertainty in Code Language Models
---

# Localized Calibrated Uncertainty in Code Language Models

<div class="paper-toolbar">
  <a href="https://arxiv.org/abs/2512.24560" class="toolbar-btn" target="_blank">📄 arXiv: 2512.24560v1</a>
  <a href="https://arxiv.org/pdf/2512.24560.pdf" class="toolbar-btn" target="_blank">📥 PDF</a>
  <button class="toolbar-btn favorite-btn" data-arxiv-id="2512.24560v1" data-paper-url="__CURRENT_PAGE__" onclick="toggleFavorite(this, '2512.24560v1', 'Localized Calibrated Uncertainty in Code Language Models')" title="添加到收藏夹">☆ 收藏</button>
  <button class="toolbar-btn" onclick="copyLinkToClipboard(this)">🔗 分享</button>
</div>


**作者**: David Gros, Prem Devanbu

**分类**: cs.SE, cs.AI

**发布日期**: 2025-12-31

---

## 💡 一句话要点

**提出代码语言模型局部校准不确定性方法，辅助LLM代码生成质量控制**

🎯 **匹配领域**: **支柱九：具身大模型 (Embodied Foundation Models)**

**关键词**: `代码语言模型` `不确定性校准` `局部化` `AI监督` `代码生成` `白盒探测` `黑盒探测`

## 📋 核心要点

1. 大型语言模型生成的代码可能偏离用户意图，缺乏有效的定位和校准不确定性的方法。
2. 提出一种局部校准不确定性的方法，通过探测技术预测代码中需要编辑的部分，辅助代码质量控制。
3. 实验表明，小型监督模型可以实现较低的校准误差和较高的Brier Skill Score，有效定位需要修改的代码行。

## 📝 摘要（中文）

大型语言模型(LLM)能够从自然语言提示生成复杂的源代码。然而，LLM生成的代码可能偏离用户意图，需要监督和编辑。为了支持这一过程，本文提出定位生成代码中可能与用户意图不一致部分的技术。首先，创建了一个“最小意图对齐补丁”数据集，其中包含修复后的LLM生成程序，并使用测试用例验证正确性。然后，评估各种技术在预测代码中哪些部分需要进行最小修改时的校准概率的能力（即，概率与实际编辑概率的对应程度）。比较了白盒探测（提出了一种高效的任意跨度查询技术）与黑盒反射和基于自洽性的方法。结果表明，使用小型监督模型的探测器可以实现较低的校准误差和约0.2的Brier Skill Score，用于估计由规模大几个数量级的模型生成的代码中需要编辑的行。讨论了该技术的泛化能力，以及与AI监督和控制的联系，发现仅在代码上训练的探测器，如果允许新的概率缩放，也显示出泛化到自然语言错误的一些迹象。

## 🔬 方法详解

**问题定义**：论文旨在解决大型语言模型（LLM）在生成代码时，输出结果与用户意图不符的问题。现有方法缺乏有效手段来定位和量化代码中潜在错误的位置，导致调试和修改效率低下。因此，需要一种能够准确预测代码中哪些部分可能需要修改的技术，以辅助人工干预和提高代码质量。

**核心思路**：论文的核心思路是训练一个探测器（probe），使其能够预测LLM生成的代码中哪些部分需要进行修改以符合用户意图。通过将代码视为一个序列，并为每个代码片段分配一个概率，表示该片段需要被编辑的可能性。该概率需要经过校准，即概率值与实际编辑的频率相对应。这样，用户可以根据探测器给出的概率，优先检查和修改高概率的代码片段。

**技术框架**：整体框架包括以下几个主要步骤：1) 创建一个包含LLM生成代码及其对应修复补丁的数据集。2) 设计并训练一个探测器，该探测器以LLM生成的代码作为输入，输出每个代码片段需要被编辑的概率。3) 评估探测器的性能，包括校准误差和Brier Skill Score等指标。4) 比较不同的探测方法，包括白盒探测、黑盒反射和基于自洽性的方法。

**关键创新**：论文的关键创新在于提出了一种高效的白盒探测技术，用于任意跨度查询。此外，论文还构建了一个包含“最小意图对齐补丁”的数据集，为训练和评估探测器提供了基础。论文还探讨了该技术的泛化能力，以及与AI监督和控制的联系。

**关键设计**：论文中，探测器可以使用小型监督模型实现，例如线性回归或小型神经网络。训练探测器的损失函数可以使用交叉熵损失或Brier Score等。为了提高探测器的泛化能力，可以使用数据增强技术，例如随机替换、删除或插入代码片段。此外，论文还提出了一种概率缩放技术，用于调整探测器输出的概率，以提高校准性能。

## 🖼️ 关键图片

<div class="paper-figures">
<figure class="paper-figure">
<img src="https://arxiv.org/html/2512.24560v1/x1.png" alt="fig_0" loading="lazy">
</figure>
<figure class="paper-figure">
<img src="https://arxiv.org/html/2512.24560v1/figs/halu_reliability_diagram_code_scaled_unscaled.png" alt="fig_1" loading="lazy">
</figure>
<figure class="paper-figure">
<img src="https://arxiv.org/html/2512.24560v1/figs/halu_reliability_diagram_code_scaled_scaled.png" alt="fig_2" loading="lazy">
</figure>
</div>

## 📊 实验亮点

实验结果表明，使用小型监督模型的探测器可以实现较低的校准误差和约0.2的Brier Skill Score，用于估计由规模大几个数量级的模型生成的代码中需要编辑的行。此外，实验还发现，仅在代码上训练的探测器，如果允许新的概率缩放，也显示出泛化到自然语言错误的一些迹象。

## 🎯 应用场景

该研究成果可应用于代码自动补全、代码审查、AI辅助编程等领域。通过定位LLM生成代码中潜在的错误，可以提高开发效率，降低调试成本，并提升软件质量。此外，该技术还可以用于评估不同LLM的代码生成能力，并为AI监督和控制提供支持。

## 📄 摘要（原文）

> Large Language models (LLMs) can generate complicated source code from natural language prompts. However, LLMs can generate output that deviates from what the user wants, requiring supervision and editing. To support this process, we offer techniques to localize where generations might be misaligned from user intent. We first create a dataset of "Minimal Intent Aligning Patches" of repaired LLM generated programs. Each program uses test cases to verify correctness. After creating a dataset of programs, we measure how well various techniques can assign a well-calibrated probability to indicate which parts of code will be edited in a minimal patch (i.e., give a probability that corresponds with empirical odds it is edited). We compare white-box probing (where we propose a technique for efficient arbitrary-span querying), against black-box reflective and self-consistency based approaches. We find probes with a small supervisor model can achieve low calibration error and Brier Skill Score of approx 0.2 estimating edited lines on code generated by models many orders of magnitude larger. We discuss the generalizability of the techniques, and the connections to AI oversight and control, finding a probe trained only on code shows some signs of generalizing to natural language errors if new probability scaling is allowed.

